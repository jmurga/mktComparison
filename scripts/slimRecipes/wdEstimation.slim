initialize() {

	//DEFINE CONSTANT TO INITIALIZE GENOMIC ELEMENT AND MUTATIONS TYPE
	defineConstant('mu', $mutRate);
	defineConstant('length', $length);
	defineConstant('bins', $bins);

	defineConstant('neutralFreq', $neutralFreq);
	defineConstant('beneficialFreq', $beneficialFreq);
	defineConstant('deleteriousFreq', $deleteriousFreq);
	defineConstant('deleteriousFitness', $deleteriousFitness);
	defineConstant('beneficialFitness', $beneficialFitness);
	defineConstant('gammaShape', $gammaShape);
	defineConstant('sample', $sample);
	defineConstant('ancSize', $ancSize);
	defineConstant('h', $h);
	
	
	//INITIALIZE ELEMENT AND MUTATIONS
	initializeMutationRate(mu);
	initializeRecombinationRate($recombRate);

	initializeMutationType('m1', h, 'f', 0);// neutral
	initializeMutationType('m2', h, 'g', deleteriousFitness, gammaShape);// deleterious
	initializeMutationType('m3', h, 'f', beneficialFitness);// beneficial

	//Non-synonymous positions
	initializeGenomicElementType('g1', c(m2,m3), c(deleteriousFreq,beneficialFreq));  
	// Synonymous positions
	initializeGenomicElementType('g2', c(m1), c(neutralFreq));
	
	types = rep(c(g1,g2), length);


	//Intercalate starts and ends with genomcis elements; each coordinate [start[0]-end[0]] contains non-synonymous positions (length==2) and synonymous positions (length==1) changing length between elements
	starts = repEach(seqLen(length) * 3, 2) + rep(c(0,2), length);	
	ends = starts + rep(c(1,0), length);
	initializeGenomicElement(types, starts, ends);
	//Example		//Example2
	//<g1> <g2>		//<g1> <g2>
	//0 	2 		//0 	1 
	//1 	2 		//0 	1 
	//l=2	l=1		//l=1	l=1


}

1 {

	sim.addSubpop('p1', $ancSize);

	sim.setValue('p0', rep(0, bins));
	sim.setValue('pi', rep(0, bins));
	sim.setValue('pneu', rep(0, bins));
	sim.setValue('pwd', rep(0, bins));
	sim.setValue('pd', rep(0, bins));

}

$burnin:$generations late()	// generations after burn-in
{
	if (sim.generation % 500 != 0)
	{
		return;
	}

	//Sample individuals
	sampledIndividuals = p1.sampleIndividuals(sample,replace=F).genomes;

	// Get m2 mutations
	gammaMuts = sortBy(unique(sampledIndividuals.mutationsOfType(m2)),'position');
	nes = (gammaMuts.selectionCoeff * ancSize);
	//Check weaklyDel through fitness coefficient in gamma distribution
	weaklyDeleterious = gammaMuts[(nes > -10) & (nes < -1)];
	weaklyDeleterious = sim.mutationFrequencies(NULL, weaklyDeleterious);

	//Check effectively neutral mutations through fitness coefficient in gamma distribution
	effectivelyNeutral = gammaMuts[nes > -1];
	effectivelyNeutral = sim.mutationFrequencies(NULL, effectivelyNeutral);

	//Check effectively neutral mutations through fitness coefficient in gamma distribution
	stronglyDeleterious = gammaMuts[(nes < -10)];
	stronglyDeleterious = sim.mutationFrequencies(NULL, stronglyDeleterious);

	//Get all mutations frequencies
	m1Sampled = sortBy(unique(sampledIndividuals.mutationsOfType(m1)),'position');
	m1Freq = sim.mutationFrequencies(NULL, m1Sampled);

	m2Sampled = sortBy(unique(sampledIndividuals.mutationsOfType(m2)),'position');
	m2Freq = sim.mutationFrequencies(NULL, m2Sampled);

	m3Sampled = sortBy(unique(sampledIndividuals.mutationsOfType(m3)),'position');
	m3Freq = sim.mutationFrequencies(NULL, m3Sampled);


	// Calculate p0 polymorphism from m1 mutations
	p0Count   = sapply(0:(bins-1), " sum((m1Freq >= applyValue / bins) & (m1Freq < (applyValue + 1) / bins)); ");
	
	// Calculate pi polymorphism from m2+m3 mutations
	m23Freq   = c(m2Freq,m3Freq);
	piCount   = sapply(0:(bins-1), " sum((m23Freq >= applyValue / bins) & (m23Freq < (applyValue + 1) / bins)); ");
	//pwdCount  = sapply(0:(bins-1), " sum((m2Freq >= applyValue / bins) & (m2Freq < (applyValue + 1) / bins)); ");
	pneuCount = sapply(0:(bins-1), " sum((effectivelyNeutral >= applyValue / bins) & (effectivelyNeutral < (applyValue + 1) / bins)); ");
	pwdCount  = sapply(0:(bins-1), " sum((weaklyDeleterious >= applyValue / bins) & (weaklyDeleterious < (applyValue + 1) / bins)); ");
	pdCount  = sapply(0:(bins-1), " sum((stronglyDeleterious >= applyValue / bins) & (stronglyDeleterious < (applyValue + 1) / bins)); ");
	
	
	// Add this generation's values in to variables	
	sim.setValue("p0", sim.getValue("p0") + p0Count);
	sim.setValue("pi", sim.getValue("pi") + piCount);
	sim.setValue("pneu", sim.getValue("pneu") + pneuCount);
	sim.setValue("pwd", sim.getValue("pwd") + pwdCount);
	sim.setValue("pd", sim.getValue("pd") + pdCount);

}
$generations late()
{


	// Get substitution and mutation info
	subs = sim.substitutions;

	m1Subs = subs[subs.mutationType == m1];
	//Any m2 substitution should be an effectively neutral mutation
	m2Subs = subs[subs.mutationType == m2];
	m3Subs = subs[subs.mutationType == m3];

	//effectivelyNeutralDiv = m2Subs[m2Subs.selectionCoeff > (-1/1000)];
	
	// Calculate d and di from substitutions of m1 and m2+m3
	d0 = m1Subs.size();
	di = m2Subs.size() + m3Subs.size();

	//Extract mi and m0
	mi = length - (length / 3);
	m0 = length / 3;
	//mi = length / 2;
	//m0 = length / 2;

 

	daf = (0:(bins-1) + 0.5) / bins;
	
	// Emit p0, pi and pwd
	p0   = sim.getValue("p0");
	pi   = sim.getValue("pi");
	pneu = sim.getValue("pneu");	
	pwd  = sim.getValue("pwd");	
	pd = sim.getValue("pd");	

	// Calculate the true alpha: m3 / (m2+m3) substitutions
	trueAlpha = m3Subs.size() / (m3Subs.size() + m2Subs.size());
	// Calculate the non-asymptotic MK estimate
	alpha = 1 - (d0/di) * (sum(pi)/sum(p0));
	
	//Estimate fractions
	f = (sum(pneu)/sum(p0)*(m0/mi));
	b = ((sum(pwd) + sum(pd))/sum(p0)*(m0/mi));
	d = 1 - (f+b);
	// Output data in the format expected by the MK web service
	catn("daf\tPi\tP0\tPneu\tPwd\tPd");
	line = "daf\tPi\tP0\tPneu\tPwd\tPd";
	writeFile("/home/jmurga/mkt/201902/scripts/slimRecipes/daf.tab", line, append=F);
	for (i in 0:(bins-1)){
		catn(daf[i] + "\t" + pi[i] + "\t" + p0[i] + "\t" + pneu[i] + "\t" + pwd[i] + "\t" + pd[i]);
		//line = daf[i] + "\t" + pi[i] + "\t" + p0[i] + "\t" + pneu[i] + "\t" + pwd[i] + "\t" + pd[i];
		//writeFile("/home/jmurga/mkt/201902/scripts/slimRecipes/daf.tab", line, append=T);
	}

	catn('D0\tDi\tm0\tmi\ttrueAlpha\tf\tb\td');
	catn(d0 + '\t' + di + '\t' + m0 + '\t' + mi + '\t' + trueAlpha + '\t' + f + '\t' + b + '\t' + d);
}
