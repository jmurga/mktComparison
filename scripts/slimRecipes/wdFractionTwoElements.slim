//  simulate_alpha.slim
//  asymptoticMK
//
//  Created by Ben Haller on 3/12/2017.
//  Copyright (c) 2017 Philipp Messer.  All rights reserved.
//  A product of the Messer Lab, http://messerlab.org/
//
//  This file is part of asymptoticMK.
//
//  asymptoticMK is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
//
//  asymptoticMK is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along with asymptoticMK.  If not, see <http://www.gnu.org/licenses/>.
// This web service should be available at http://benhaller.com/messerlab/asymptoticMK.html
// The Github repository for asymptoticMK is at https://github.com/MesserLab/asymptoticMK
initialize() {
	// These are the parameters we vary; the run length is varied by modifying the
	// generations used for the events below.
	// This is the baseline recipe modificate to parse any value on python script

	//DEFINE CONSTANT TO INITIALIZE GENOMIC ELEMENT AND MUTATIONS TYPE
	defineConstant('mu', $mutRate);
	defineConstant('length', $length);

	defineConstant('r_f', $rf);
	defineConstant('r_b', $rb);
	defineConstant('r_d', $rd);
	defineConstant('s_d', $sd);
	defineConstant('s_b', $sb);
	defineConstant('h', $h);

	//INITIALIZE ELEMENT AND MUTATIONS
	initializeMutationRate(mu);
	initializeMutationType('m1', $h, 'f', 0.0);// neutral
	initializeMutationType('m4', h, 'f', 0.0);// neutral
	//initializeMutationType('m2', $h, 'g', s_d, 0.2);// deleterious
	initializeMutationType('m2', $h, 'f', s_d);// deleterious
	initializeMutationType('m3', $h, 'f', s_b);// beneficial


	initializeGenomicElementType('g1', c(m1), c(1)); //mS
	initializeGenomicElementType('g2', c(m4, m2, m3), c(r_f,r_d,r_b)); //mN
	//initializeGenomicElementType('g2', c(m4, m2, m3), c(1,0,0)); //mN
	initializeGenomicElement(g2, 0, length);
	initializeGenomicElement(g1, length+1, (length+1e6+1));

	initializeRecombinationRate($recombRate);

}

1 {

	sim.addSubpop('p1', $ancSize);

	sim.setValue('p_0_acc', rep(0, $bins));
	sim.setValue('p_acc', rep(0, $bins));
	sim.setValue('p_wd', rep(0, $bins));
	sim.setValue('p_b', rep(0, $bins));
	sim.setValue('p_neu', rep(0, $bins));

}

$burnin:$generations late()	// generations after burn-in
{
	if (sim.generation % 500 != 0)
		return;
	
	muts = sim.mutations;
	
	gammaMuts = sim.mutationsOfType(m2);
	gammaMuts = gammaMuts[gammaMuts.selectionCoeff < (-1/$ancSize) & gammaMuts.selectionCoeff > -0.009];
	gammaMuts = sim.mutationFrequencies(NULL, gammaMuts);

	freqs = sim.mutationFrequencies(NULL);
	m1_f = freqs[muts.mutationType == m1];
	m2_f = freqs[muts.mutationType == m2];
	m3_f = freqs[muts.mutationType == m3];
	m4_f = freqs[muts.mutationType == m4];

	// Calculate p_0 from polymorphism in m1 mutations
	p_0 = sapply(0:($bins-1), " sum((m1_f >= applyValue / $bins) & (m1_f < (applyValue + 1) / $bins)); ");

	// Calculate p from polymorphism in m2+m3 mutations
	m42_f = c(m4_f,m2_f);
	p = sapply(0:($bins-1), " sum((m42_f >= applyValue / $bins) & (m42_f < (applyValue + 1) / $bins)); ");
	pNeu = sapply(0:($bins-1), " sum((m4_f >= applyValue / $bins) & (m4_f < (applyValue + 1) / $bins)); ");
	// Calculate sligthly deleterious polymorphism
	//pWd = sapply(0:($bins-1), " sum((gammaMuts >= applyValue / $bins) & (gammaMuts < (applyValue + 1) / $bins)); ");
	pWd = sapply(0:($bins-1), " sum((m2_f >= applyValue / $bins) & (m2_f < (applyValue + 1) / $bins)); ");
	pb = sapply(0:($bins-1), "sum((m3_f >= applyValue / $bins) & (m3_f < (applyValue + 1) / $bins)); ");
	
	// Add this generation's values in to our accumulators
	sim.setValue("p_0_acc", sim.getValue("p_0_acc") + p_0);
	sim.setValue("p_acc", sim.getValue("p_acc") + p);
	sim.setValue("p_wd", sim.getValue("p_wd") + pWd);
	sim.setValue("p_b", sim.getValue("p_b") + pb);
	sim.setValue("p_neu", sim.getValue("p_neu") + pNeu);

}

$generations late()
{


	// Get substitution and mutation info
	subs = sim.substitutions;
	m1_subs = subs[subs.mutationType == m1];
	m2_subs = subs[subs.mutationType == m2];
	m3_subs = subs[subs.mutationType == m3];
	m4_subs = subs[subs.mutationType == m4];
		// Calculate d_0 and d from substitutions of m1 and m2+m3
	d_0 = m1_subs.size();
	d = m4_subs.size() + m3_subs.size();
	cat("D0:" + d_0 + "\n");
	cat("Di:" + d + "\n");
	
	// Emit f, the centers of our frequency bins (assumed in the code below)
	f = (0:($bins-1) + 0.5) / $bins;
	//cat("f: " + paste(f) + "\n");
	
	// Emit p_0, p and p_wd
	p_0 = sim.getValue("p_0_acc");
	p = sim.getValue("p_acc");
	p_wd = sim.getValue("p_wd");	
	p_b = sim.getValue("p_b");	
	p_neu = sim.getValue("p_neu");	

	
	// Calculate the true alpha: m3 / (m2+m3) substitutions
	true_alpha = m3_subs.size() / (m2_subs.size() + m3_subs.size() + m4_subs.size());
	cat("True alpha:" + true_alpha + "\n");
	
	// Calculate the non-asymptotic MK estimate
	MK_alpha = 1 - (d_0/d) * (sum(p)/sum(p_0));
	cat("MK alpha:" + MK_alpha + "\n");
	
	// Output data in the format expected by the MK web service
	cat("daf\tPi\tP0\tPneu\tPwd\n");
	//line = "daf\tPi\tP0\tPwd\tPb";
	//writeFile("/home/jmurga/wd.txt", line, append=F);
	
	for (i in 0:($bins-1)){
		cat(f[i] + "\t" + p[i] + "\t" + p_0[i] + "\t" + p_neu[i] + "\t" + p_wd[i] + "\n");
		//line = f[i] + "\t" + p[i] + "\t" + p_0[i] + "\t" + p_wd[i] + "\t" + p_b[i];
		//writeFile("/home/jmurga/wd.txt", line, append=T);
	}

	cat("m0:" + ((length+1e6+1) - (length+1)) + "\n");
	cat("mi:" + length + "\n");
	cat("b:" + (sum(p_wd)/sum(p_0)*((length+1e6+1 - (length+1)))/length) + "\n");
	
/*	line = "D0\tDi\tm0\tmi";
	writeFile("/home/jmurga/wdDiv.txt", line, append=F);
	line = d_0 + "\t" + d + "\t" + length + "\t" + length;
	writeFile("/home/jmurga/wdDiv.txt", line, append=T);*/

}
